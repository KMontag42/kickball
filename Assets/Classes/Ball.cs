// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using UnityEngine;
using TouchScript.Events;
using TouchScript.Gestures;
using System.Collections;

public class Ball : MonoBehaviour
{
	public Pitcher Pitcher;
	public Player Player;
	public ExtraPitch ExtraPitch;

	//private bool destroyMe = false;
	public bool beingThrown = false;
	public bool beingHit = false;
	private Vector3 throwingVelocity;
	private float throwingTorque;
	private Vector3 hitVelocity;

	//private float maxVelocity = 15.0f;
	//private float sqrMaxVelocity = 15 * 15;

	public GameObject mainCamera;
	private Vector3 cameraStart;
	private Quaternion cameraStartRotation;
	private Vector3 startPosition;
	private Vector3 flickStart;
	public bool canHit = false;
	
	public GameObject SingleText;
	public GameObject DoubleText;
	public GameObject TripleText;
	public GameObject HomeRunText;
	public GameObject FoulText;
	public GameObject SwingNowText;
	
	public float flickDistanceFromHome;
	public float flickDivisor;
	
	public bool isHomeRun = false;
	public bool beenHit = false;

	private ParticleSystem hitParticleSystem;
	
	void Awake ()
	{
		cameraStart = mainCamera.transform.position;
		cameraStartRotation = mainCamera.transform.rotation;
		startPosition = transform.position;

		hitParticleSystem = GetComponent<ParticleSystem>();

		GetComponent<FlickGesture> ().StateChanged += flickHandler;
		GetComponent<PressGesture> ().StateChanged += pressHandler;
	}

	void OnCollisionEnter (Collision collision)
	{
		if (Pitcher != null) {
			if (collision.gameObject.name == "Ground" && beenHit) {
				ResetBall ();
				Player.ChangeScore(-1);
				StartCoroutine (BounceAlertText (FoulText));
			} else if (collision.gameObject.name == "Extra Pitch" && beenHit) {
				ExtraPitch.BallHit ();
			}
		}
	}

	void OnTriggerEnter (Collider collision)
	{
		if (collision.gameObject.name == "HitZoneStart") {
			canHit = true;
			
			if (Player.isTutorialPitch) {
				(GetComponent ("Halo") as Behaviour).enabled = true;
				Time.timeScale = 0.3f;
				StartCoroutine(BounceAlertText(SwingNowText));
			}
			
		} else if (collision.gameObject.name == "Hit Zone End") {
			canHit = false;
			
			if (Player.isTutorialPitch) {
				(GetComponent ("Halo") as Behaviour).enabled = false;
				
			}
			
			Time.timeScale = 1;
			
		} else if (collision.gameObject.name == "Single" && beenHit) {
			CatchBall ();
			Player.ChangeScore(1);
			Player.HitNotHomeRun();
			Debug.Log ("hit ground - single");

			StartCoroutine (BounceAlertText (SingleText));

		} else if (collision.gameObject.name == "Double" && beenHit) {
			CatchBall ();
			Player.ChangeScore(2);
			Player.HitNotHomeRun();
			Debug.Log ("hit ground - double");

			StartCoroutine (BounceAlertText (DoubleText));

		} else if (collision.gameObject.name == "Triple" && beenHit) {
			CatchBall ();
			Player.ChangeScore(3);
			Player.HitNotHomeRun();
			Debug.Log ("hit ground - triple");

			StartCoroutine (BounceAlertText (TripleText));

		} else if (collision.gameObject.name == "Home Run" && beenHit) {
			CatchBall ();
			Player.ChangeScore(5);
			Player.HitHomeRun();
			Debug.Log ("hit ground - home run");

			StartCoroutine (BounceAlertText (HomeRunText));

		} else if (collision.gameObject.name == "Strike") {
			ResetBall ();
			Player.ChangeScore(-1);
			Player.HitFoulOrStrike();
		} else if (collision.gameObject.name == "Foul") {
			ResetBall ();
			Player.ChangeScore(-1);
			Player.HitFoulOrStrike();
			StartCoroutine (BounceAlertText (FoulText));
		}
	}

	public void CatchBall ()
	{
		ResetBall ();
	}

	public void ThrowBall (Vector3 velocity, float torque)
	{
		if (Player.remainingPitches > 0) {
			rigidbody.constraints = RigidbodyConstraints.None;

			beingThrown = true;

			rigidbody.AddForceAtPosition (velocity, transform.position);
			if (!Player.isTutorialPitch)
				constantForce.force = new Vector3(torque, torque, 0);
		}
	}

	public void ResetBall ()
	{
		beingThrown = false;
		beingHit = false;
		beenHit = false;
		rigidbody.velocity = Vector3.zero;
		transform.position = startPosition;
		rigidbody.constraints = RigidbodyConstraints.FreezeAll;
		Player.remainingPitches--;
		if (Player.remainingPitches <= 0) {
			// end game
		}
		(GetComponent ("Halo") as Behaviour).enabled = false;
		GetComponent<TrailRenderer> ().enabled = false;

		if (Random.Range (0f, 1f) > .5f) {
			ExtraPitch.ResetPosition ();
		}
		
		isHomeRun = false;
		
		Time.timeScale = 1;
	}

	void Update ()
	{
//		if(beenHit && rigidbody.velocity.sqrMagnitude > sqrMaxVelocity){ // Equivalent to: rigidbody.velocity.magnitude > maxVelocity, but faster.
//			// Vector3.normalized returns this vector with a magnitude 
//			// of 1. This ensures that we're not messing with the 
//			// direction of the vector, only its magnitude.
//			rigidbody.velocity = rigidbody.velocity.normalized * maxVelocity;
//		}

		if (beenHit) {
			if (!isHomeRun) {
				mainCamera.GetComponent<SmoothLookAt> ().target = gameObject.transform;
				mainCamera.GetComponent<SmoothFollow> ().target = gameObject.transform;
			} else {
				mainCamera.transform.position = cameraStart;
				mainCamera.transform.rotation = cameraStartRotation;
				mainCamera.GetComponent<SmoothLookAt> ().target = null;
				mainCamera.GetComponent<SmoothFollow> ().target = null;
			}
			

			if (transform.position.z > 900) {
				CatchBall ();
				Player.ChangeScore(5);
				Debug.Log ("past bounds - home run");
			
				StartCoroutine (BounceAlertText (HomeRunText));
			}

		} else {
			mainCamera.transform.position = cameraStart;
			mainCamera.transform.rotation = cameraStartRotation;
			mainCamera.GetComponent<SmoothLookAt> ().target = null;
			mainCamera.GetComponent<SmoothFollow> ().target = null;
		}
	}

	private void flickHandler (object sender, GestureStateChangeEventArgs e)
	{
		//FlickGesture flick = (sender as FlickGesture);
	
		if (e.State == Gesture.GestureState.Recognized && beingHit) {
			//Vector2 spd = ((sender as FlickGesture).ScreenFlickVector/(sender as FlickGesture).ScreenFlickTime);
		
			Vector3 flickDirection = new Vector3 ((sender as FlickGesture).ScreenFlickVector.x, (sender as FlickGesture).ScreenFlickVector.y, (sender as FlickGesture).ScreenFlickVector.y);
			
			flickDistanceFromHome = Vector3.Distance (transform.position, GameObject.Find ("Hit Zone End").transform.position);

			flickDivisor = 1.5f / Vector3.Distance (transform.position, GameObject.Find ("Hit Zone End").transform.position);
			
			if (flickDivisor >= 1f) {
				isHomeRun = true;
			}
			
			hitParticleSystem.Emit((int)(100 * flickDivisor));

			flickDirection.Scale (new Vector3 (1 * flickDivisor, .5f * flickDivisor, 1 * flickDivisor));

			rigidbody.AddForceAtPosition (flickDirection, flickStart);
			
			constantForce.force = Vector3.zero;
			
			canHit = false;
			beingHit = false;
			beenHit = true;

			GetComponent<TrailRenderer> ().enabled = true;
			
			Time.timeScale = 1;
		}
	}

	private void pressHandler (object sender, GestureStateChangeEventArgs e)
	{
		PressGesture press = (sender as PressGesture);
	
		if (e.State == Gesture.GestureState.Ended && canHit) {
			Debug.Log ("pressed");
			flickStart = mainCamera.camera.ScreenToWorldPoint (press.ScreenPosition);
			beingHit = true;
		}
	}

	private IEnumerator BounceAlertText (GameObject textToBound)
	{
		yield return StartCoroutine (MoveObject (textToBound.transform, textToBound.transform.position, new Vector3 (textToBound.transform.position.x, textToBound.transform.position.y + 6, textToBound.transform.position.z), .5f));
		yield return StartCoroutine (MoveObject (textToBound.transform, textToBound.transform.position, new Vector3 (textToBound.transform.position.x, textToBound.transform.position.y - 6, textToBound.transform.position.z), .5f));
	}

	private IEnumerator MoveObject (Transform thisTransform, Vector3 startPos, Vector3 endPos, float time)
	{
		float i = 0.0f;
		float rate = 1.0f / time;
		while (i < 1.0f) {
			i += Time.deltaTime * rate;
			thisTransform.position = Vector3.Lerp (startPos, endPos, i);
			yield return null;
		}
	}
}