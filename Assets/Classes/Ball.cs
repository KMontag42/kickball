// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using UnityEngine;
using TouchScript.Events;
using TouchScript.Gestures;

public class Ball : MonoBehaviour
{
	public Pitcher Pitcher;
	public Player Player;

	//private bool destroyMe = false;
	public bool beingThrown = false;
	public bool beenHit = false;

	private Vector3 throwingVelocity;
	private float throwingTorque;

	private Vector3 hitVelocity;

	//private float maxVelocity = 15.0f;
	//private float sqrMaxVelocity = 15 * 15;

	public GameObject mainCamera;
	private Vector3 cameraStart;
	private Quaternion cameraStartRotation;

	private Vector3 startPosition;

	private Vector3 flickStart;

	public bool canHit = false;

	void Awake()
	{
		cameraStart = mainCamera.transform.position;
		cameraStartRotation = mainCamera.transform.rotation;
		startPosition = transform.position;

		GetComponent<FlickGesture>().StateChanged += flickHandler;
		GetComponent<PressGesture>().StateChanged += pressHandler;
	}

	void OnCollisionEnter (Collision collision)
	{
		if (Pitcher != null) {
			if (collision.gameObject.name == "Single") {
				CatchBall ();
				Player.Score += 1;
				Debug.Log("hit ground - single");
			} else if (collision.gameObject.name == "Double") {
				CatchBall ();
				Player.Score += 2;
				Debug.Log("hit ground - double");
			} else if (collision.gameObject.name == "Triple") {
				CatchBall ();
				Player.Score += 3;
				Debug.Log("hit ground - triple");
			} else if (collision.gameObject.name == "Home Run") {
				CatchBall ();
				Player.Score += 4;
				Debug.Log("hit ground - home run");
			} else if (collision.gameObject.name == "Strike") {
				ResetBall();
				Player.Score -= 1;
			} else if (collision.gameObject.name == "Ground" && beenHit) {
				ResetBall();
				Player.Score -= 1;
			}
		}
	}

	void OnTriggerEnter(Collider collision)
	{
		Debug.Log(collision.gameObject.name);
		if (collision.gameObject.name == "HitZoneStart") {
			canHit = true;
			(GetComponent("Halo") as Behaviour).enabled = !beenHit;
		} else if (collision.gameObject.name == "Hit Zone End") {
			canHit = false;
			(GetComponent("Halo") as Behaviour).enabled = false;
		}
	}
	
	public void CatchBall()
	{
		ResetBall ();
	}

	public void ThrowBall(Vector3 velocity, float torque)
	{
		if (Player.remainingPitches > 0) {
			rigidbody.constraints = RigidbodyConstraints.None;

			throwingVelocity = velocity;

			throwingTorque = torque;

			beingThrown = true;

			rigidbody.AddForce (throwingVelocity);
			rigidbody.AddTorque (Vector3.forward * throwingTorque);
		}
	}

	public void ResetBall()
	{
		beingThrown = false;
		beenHit = false;
		rigidbody.velocity = Vector3.zero;
		transform.position = startPosition;
		rigidbody.constraints = RigidbodyConstraints.FreezeAll;
		Player.remainingPitches--;
		if (Player.remainingPitches <= 0) {
			// end game
		}
		(GetComponent("Halo") as Behaviour).enabled = false;
		GetComponent<TrailRenderer>().enabled = false;
	}

	void Update()
	{
//		if(beenHit && rigidbody.velocity.sqrMagnitude > sqrMaxVelocity){ // Equivalent to: rigidbody.velocity.magnitude > maxVelocity, but faster.
//			// Vector3.normalized returns this vector with a magnitude 
//			// of 1. This ensures that we're not messing with the 
//			// direction of the vector, only its magnitude.
//			rigidbody.velocity = rigidbody.velocity.normalized * maxVelocity;
//		}

		if (beenHit) {
			mainCamera.GetComponent<SmoothLookAt>().target = gameObject.transform;
			mainCamera.GetComponent<SmoothFollow>().target = gameObject.transform;
		} else {
			mainCamera.transform.position = cameraStart;
			mainCamera.transform.rotation = cameraStartRotation;
			mainCamera.GetComponent<SmoothLookAt>().target = null;
			mainCamera.GetComponent<SmoothFollow>().target = null;
		}
	}

	private void flickHandler(object sender, GestureStateChangeEventArgs e)
	{
		//FlickGesture flick = (sender as FlickGesture);
		
		if (e.State == Gesture.GestureState.Recognized && beenHit) {
			//Vector2 spd = ((sender as FlickGesture).ScreenFlickVector/(sender as FlickGesture).ScreenFlickTime);
			
			Vector3 flickDirection = new Vector3((sender as FlickGesture).ScreenFlickVector.x, (sender as FlickGesture).ScreenFlickVector.y, (sender as FlickGesture).ScreenFlickVector.y);
			
			Debug.Log("flickDirection  " + flickDirection);

			Debug.Log (Vector3.Distance(transform.position, GameObject.Find("Hit Zone End").transform.position));

			float divisor = 4 / Vector3.Distance(transform.position, GameObject.Find("Hit Zone End").transform.position);

			flickDirection.Scale(new Vector3(1 * divisor,.5f * divisor, 1 * divisor));

			rigidbody.AddForceAtPosition(flickDirection, flickStart);

			/* TODO
			 * scale the veloc based on how close to the end of the hit zone we are
			 * make camera less shitty
			 * foul ball zone
			 * 
			 */

			canHit = false;
			beenHit = true;

			GetComponent<TrailRenderer>().enabled = true;
		}
	}

	private void pressHandler(object sender, GestureStateChangeEventArgs e)
	{
		PressGesture press = (sender as PressGesture);

		Debug.Log(press.ScreenPosition);
		
		if (e.State == Gesture.GestureState.Ended && canHit) {
			Debug.Log("pressed");
			flickStart = mainCamera.camera.ScreenToWorldPoint(press.ScreenPosition);
			beenHit = true;
		}
	}
}